# DFS (Depth-First Search)
* DFS는 **깊이 우선 탐색** 이라고도 부르며 그래프에서 **깊은 부분을 우선적으로 탐색하는 알고리즘** 이다.
* DFS를 설명하기 전에 먼저 **그래프의 기본 구조** 를 알아보자.

### 그래프(Graph)의 기본 구조
* 그래프는 **노드(Node)** 와 **간선(Edge)** 으로 표현되며 이때 노드를 **정점(Vertex)** 이라고도 한다.  
![image](https://user-images.githubusercontent.com/78528903/179976356-03fb610e-7751-4620-a6a4-8c6748374f1b.png)

* 그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다.
* 또한 두 노드가 간선으로 연결되어 있다면 '두 노드는 인접하다'라고 표현한다.
<br/>

프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있는데 코딩 테스트에서는 이 두 방식 모두 필요하니 두 개념에 대해 바르게 알고 있도록 하자.
* 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
* 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식
<br/>

**인접 행렬 방식**  
![image](https://user-images.githubusercontent.com/78528903/179976763-498662ca-dc46-49ea-8891-0b9eeb92f81f.png)

* 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식
* 위와 같이 연결된 그래프를 인접 행렬로 표현할 때 파이썬에서는 2차원 리스트로 구현할 수 있다.
* 연결이 되어 있지 않은 노드끼리는 무한의 비용이라고 작성한다.
```python
INF = 1e9

# 2차원 리스트를 이용해 인접 행렬 표현
graph = [
  [0, 7, 5],
  [7, 0, INF],
  [5, INF, 0]
]

print(graph)

>>>
[[0, 7, 5], [7, 0, 1e9], [5, qe9, 0]]
```  
<br/>  

**인접 리스트 방식**  
![image](https://user-images.githubusercontent.com/78528903/179977452-b830045a-933b-4789-ad46-74ddbb8b5861.png)

* 위 그림처럼 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장한다.
* 인접 리스트는 '연결 리스트'라는 자료구조를 이용해 구현
* 파이썬은 기본자료형인 리스트 자료형이 `append()`와 메소드를 제공하므로, 전통적인 프로그래밍 언어에서의 배열과 연결 리스트의 기능을 모두 기본으로 제공한다.
* 파이썬으로 인접 리스트를 이용해 그래프를 표현하고자 할 때에도 단순히 2차원 리스트를 이용하면 된다는 점만 기억하자.
```python
# 행(Row)이 3개인 2차원 리스트로 인접 리스트 표현
graph = [[] for _ in range(3)]

# 노드 0에 연결된 노드 정보 저장(노드, 거리)
graph[0].append((1, 7))
graph[0].append((2, 5))

# 노드 1에 연결된 노드 정보 저장(노드, 거리)
graph[1].append((0, 7))

# 노드 2에 연결된 노드 정보 저장(노드, 거리)
graph[2].append((0, 5))

print(graph)

>>>
[[(1, 7), (2, 5)], [(0, 7)], [(0, 5)]]
```
<br/>

**이 두 방식은 어떤 차이가 있을까?**  

코딩 테스트를 위해 학습하는 터라 메모리와 속도 측면에서 살펴 보겠다.  
메모리	측면에서 보자면 **인접 행렬 방식은** 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비된다.  
반면에 **인접 리스트 방식** 은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다.  

하지만	이와 같은 속성 때문에 **인접 리스트 방식은**	인접 행렬 방식에 비해 특정한 두 노드가 연결되어	있는지에 대한	*정보를 얻는 속도가 느리다.* 인접 리스트 방식에서는 연결된 데이터를 하나씩 확인해야 하기 때문이다.  
예를 들어 노드 1과	노드 7이 연결되어 있는지 확인해보자. 인접 행렬 방식에서는 graph[1][7]만 확인하면된다. 
반면에 인접 리스트 방식에서는 노드 1에 대한 인접 리스트를 앞에서부터 차례대로 확인해야 한다.  
그러므로 **특정한 노드와 연결된 모든 인접 노드를 순회해야 하는 경우, 인접 리스트 방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적다.**

<br/>

## DFS 동작 원리

* DFS는 **스택 자료구조(혹은 재귀 함수)를 이용** 하며, 구체적인 동작 과정은 다음과 같다.
  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
  2. 스택의 **최상단 노드에 방문하지 않은 인접한 노드** 가 하나라도 있으면 그 노드를 스택에 넣고 방문처리한다. 방문하지 않은 인접 노드가 **없으면 스택에서 최상단 노드를 꺼낸다.**
  3. 더 이상 2번의 과정을 수핼할 수 없을 때까지 반복한다. 

## DFS 동작 예시

* **[Step 0]** 그래프를 준비합니다. ( **방문 기준** : 번호가 낮은 인접 노드부터, 문제에 따라 다를 수 있다. )
  * 시작 노드 : 1  
  ![image](https://user-images.githubusercontent.com/78528903/179973956-9288ce7d-166d-4ad7-ae9f-db89b885444f.png)
  
* **[Step 1]** 시작 노드인 '1'을 스택에 삽입하고 방문 처리 합니다.  
![image](https://user-images.githubusercontent.com/78528903/179974420-71a23734-a281-4989-83b2-b9b45c56d24e.png)

* **[Step 2]** 스택의 최상단 노드인 '1'에 방문하지 않은 인접 노드 '2', '3', '8'이 있습니다.
  * 이 중에서 가장 작은 노드인 '2'를 스택에 넣고 방문 처리를 합니다.  
  ![image](https://user-images.githubusercontent.com/78528903/179974629-0ec21575-4be5-4abf-816e-3e9428b89d43.png)

* **[Step 3]** 스택의 최상단 노드인 '2'에 방문하지 않은 인접 노드 '7'이 있습니다.
  * 따라서 '7'번 노드를 스택에 넣고 방문 처리를 합니다.  
  ![image](https://user-images.githubusercontent.com/78528903/179974832-b65b4b6a-9e58-48bd-aef4-b3876023f5aa.png)

* **[Step 4]** 스택의 최상단 노드인 '7'에 방문하지 않은 인접노드 '6', '8'이 있습니다.
  * 이 중에서 가장 작은 노드인 '6'을 스택에 넣고 방문 처리를 합니다.  
  ![image](https://user-images.githubusercontent.com/78528903/179975043-5c19c0a7-272f-4f5d-81ea-84e210c004ce.png)

* **[Step 5]** 스택의 최상단 노드인 '6'에 방문하지 않은 인접 노드가 없습니다.
  * 따라서 스택에서 '6'번 노드를 꺼냅니다.  
  ![image](https://user-images.githubusercontent.com/78528903/179975169-49e6feac-bacd-4e93-947c-90cd73a18f01.png)

* **[Step 6]** 스택의 최상단 노드인 '7'에 방문하지 않은 인접 노드 '8'이 있습니다.
  * 따라서 '8'번 노드를 스택에 넣고 방문 처리를 합니다.  
  ![image](https://user-images.githubusercontent.com/78528903/179975308-d1085985-4b4b-454c-b83c-1c607a9272eb.png)

* 이러한 과정을 반복하였을 때 **전체 노드의 탐색 순서** (스택에 들어간 순서)는 다음과 같습니다.  
![image](https://user-images.githubusercontent.com/78528903/179975371-0795dc8e-7a6a-454b-a40b-f53431fd5878.png)

* 깊이 우선 탐색 알고리즘인 DFS는 탐색을 수행함에 있어서 테이터의 개수가 N개인 경우 **$O(N)$** 의 시간이 소요된다.

```python
# DFS 메서드 정의
def dfs(graph, v, visited):
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end=' ')
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
    	    dfs(graph, i, visited)

# 각 노드가 연결된 정보를 표현 (2차원 리스트)
graph = [
    [], # 일반적으로 그래프 문제가 출제되면 노드의 번호가 1번부터 시작하는 경우가 많기 때문에 index 0에 대한 내용은 비워두자
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

# 각 노드가 방문된 정보를 표현 (1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출
dfs(graph, 1, visited)

>>>
1 2 7 6 8 3 4 5
```

<br/>

# BFS (Breadth-First Search)

* BFS는 **너비 우선 탐색** 이라고도 부르며, 그래프에서 **가까운 노드부터 우선적으로 탐색하는 알고리즘** 이다.
* BFS는 **큐 자료구조** 를 이용하며, 구체적인 동작 과정은 다음과 같다.
  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
  2. 큐에서 **노드를 꺼낸 뒤에** 해당 노드의 인접 노드 중에서 **방문하지 않은 노드를 모두 큐에 삽입** 하고 방문 처리한다.
  3. 더 이상 2번의 과정을 수행할 수 없을때 까지 반복한다.

## BFS 동작 예시  
* **[Step 0]** 그래프를 준비한다. ( **방문 기준** : 번호가 낮은 인접 노드부터, 방문 기준은 문제에 따라 다를 수 있음 )
  * 시작 노드: 1  
  ![image](https://user-images.githubusercontent.com/78528903/180001196-3f602dca-e9e7-4724-89a3-6bba25acd282.png)

* **[Step 1]** 시작 노드인 '1'을 큐에 삽입하고 방문 처리를 한다.  
![image](https://user-images.githubusercontent.com/78528903/180001257-59b7df4c-b008-49ff-89f8-b4b62ed51017.png)

* **[Step 2]** 큐에서 노드 '1'을 꺼내고 방문하지 않은 인접 노드 '2', '3', '8'을 모두 큐에 삽입하고 방문 처리를 한다.  
![image](https://user-images.githubusercontent.com/78528903/180001303-de8becac-54fc-4d35-9e9b-0d6b339c4d95.png)

* **[Step 3]** 큐에서 노드 '2'를 꺼내고 방문하지 않은 인접 노드 '7'을 큐에 삽입하고 방문 처리를 한다.  
![image](https://user-images.githubusercontent.com/78528903/180001319-b2fd3da2-a1f8-4007-9d73-e180f859ecbb.png)

* **[Step 4]** 큐에서 노드 '3'을 꺼내고 방문하지 않은 인접 노드 '4'와 '5'를 모두 큐에 삽입하고 방문처리를 한다.  
![image](https://user-images.githubusercontent.com/78528903/180001336-f1a9fba7-42a1-41aa-998c-81a383faf7ef.png)

* **[Step 5]** 큐에서 노드 '8'을 꺼내고 방문하지 않은 인접 노드가 없으므로 무시한다.  
![image](https://user-images.githubusercontent.com/78528903/180001351-cabd1418-322b-4a52-9848-e03b93e02671.png)

* **[Step 6]** 큐에서 노드 '7'을 꺼내고 방문하지 않은 인접 노드 '6'을 큐에 삽입하고 방문 처리를 한다.  
![image](https://user-images.githubusercontent.com/78528903/180001375-2e743af2-b081-4253-b1cc-0b136d8471ec.png)

* **[Step 7]** 남아 있는 노드에 방문하지 않은 인접 노드가 없다. 따라서 모든 노드를 차례대로 꺼내면 최종적으로 다음과 같다.  
![image](https://user-images.githubusercontent.com/78528903/180001908-5901104d-c8a2-4dc7-98f4-2c11309d4fca.png)
  * 모든 간선의 비용이 1이라고 가정할때, 탐색 순서를 보면 시작 노드인 '1'에서 부터 거리가 1인 2와 3, 거리가 2인 4, 5, 7, 마지막으로 거리가 가장 먼 6이 순서대로 탐색되는 것을 확인할 수 있다.
  * BFS는 이러한 특징 때문에 각 간선의 비용이 모두 동일한 상황에서 **최단 거리 문제** 를 해결하기 위한 목적으로 사용할 수도 있다.

```python
from collections import deque

# BFS 메서드 정의
def bfs(graph, start, visited):
    # 큐(Queue) 구현을 위해 deque 라이브러리 사용
    queue = deque([start])
    # 현재 노드를 방문 처리
    visited[start] = True
    # 큐가 빌 때까지 반복
    while queue:
      # 큐에서 하나의 원소를 뽑아 출력하기
      v = queue.popleft()
      print(v, end=' ')
      # 아직 방문하지 않은 인접한 원소들을 큐에 삽입
      for i in graph[v]:
          if not visited[i]:
    	      queue.append(i)
            visited[i] = True

# 각 노드가 연결된 정보를 표현 (2차원 리스트)
graph = [
    [], # 일반적으로 그래프 문제가 출제되면 노드의 번호가 1번부터 시작하는 경우가 많기 때문에 index 0에 대한 내용은 비워두자
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

# 각 노드가 방문된 정보를 표현 (1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출
bfs(graph, 1, visited)

>>>
1 2 3 8 7 4 5 6
```
