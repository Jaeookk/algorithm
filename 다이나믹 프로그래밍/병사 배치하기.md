## 문제 설명
* N명의 병사가 무작위로 나열되어 있습니다. 각 병사는 특정한 값의 전투력을 보유하고 있습니다.
* 병사를 배치할 때는 **전투력이 높은 병사가 앞쪽에 오도록 내림차순으로 배치** 를 하고자 합니다. 다시 말해 앞쪽에 있는 병사의 전투력이 항상 뒤쪽에 있는 병사보다 높아야 합니다.
* 또한 배치 과정에서는 특정한 위치에 있는 병사를 열외시키는 방법을 이용합니다. 그러면서도 남아 있는 병사의 수가 최대가 되도록 하고 싶습니다.
* 예를 들어 N = 7일 때, 나열된 병사들의 전투력이 다음과 같다고 가정하겠습니다.  
![image](https://user-images.githubusercontent.com/78528903/182307096-6ff3888b-0ab9-45fc-a9cc-79312cade560.png)

* 이때 3번 병사와 6번 병사를 열외시키면, 다음과 같이 남아 있는 병사의 수가 내림차의 형태가 되며 5명이 됩니다. 이는 남아 있는 병사의 수가 최대가 되도록 하는 방법입니다.  
![image](https://user-images.githubusercontent.com/78528903/182307237-299c93f5-e572-436e-9819-a757d31c2807.png)

* 병사에 대한 정보가 주어졌을 때, 남아 있는 병사의 수가 최대가 되도록 하기 위해서 열외시켜야 하는 병사의 수를 출력하는 프로그램을 작성하세요.


## 문제 조건
* 입력 조건
    * 첫째 줄에 N이 주어집니다. (1 <= N <= 2,000)  
    둘째 줄에 각 병사의 전투력이 공백으로 구분되어 차례대로 주어집니다. 각 병사의 전투력은 10,000,000보다 작거나 같은 자연수입니다.
* 출력 조건
    * 첫째 줄에 남아 있는 병사의 수가 최대가 되도록 하기 위해서 열외시켜야 하는 병사의 수를 출력합니다.

![image](https://user-images.githubusercontent.com/78528903/182307642-9ce946aa-b839-435d-bd68-152a4b3928fd.png)



## 문제 해결 아이디어
* 이 문제의 기본 아이디어는 **가장 긴 증가하는 부분 수열(Longest Increasing Subsequence, LIS)** 로 알려진 전형적인 다이나믹 프로그래밍 문제의 아이디어와 같다.
* 예를 들어 하나의 수열 `array = {4, 2, 5, 8, 4, 11, 15}`이 있다고 하자.
    * 이 수열의 가장 긴 증가하는 부분 수열은 `{4, 5, 8, 11, 15}` 이다.
* 이 문제는 가장 긴 감소하는 부분 수열을 ㅊ자는 문제로 치환할 수 있으므로, LIS 알고리즘을 조금 수정하여 적용함으로써 정답을 도출할 수 있다.

<br/>

### **가장 긴 증가하는 부분 수열 (LIS) 알고리즘**
* D[i] = array[i]를 마지막 원소로 가지는 부분 수열의 최대 길이
* 점화식은 다음과 같다.
    * **모든 0 <= j <= i에 대하여, `D[i] = max(D[i], D[j] + 1) if array[j] < array[i]`**

<br/>

* **Step 0**  
i = 0일 때는 다음과 같이 테이블을 갱신한다. 이때 부분수열을 만들때 각각의 원소 하나만 이용해서 만들면 그 길이는 1이 되기 때문에, 각 원소를 마지막 원소로 가지는 부분수열의 최대 길이를 구한다 했을때 1이므로 1로 DP를 초기화한다.  
![image](https://user-images.githubusercontent.com/78528903/182310793-c024e426-8057-4675-bce0-ec4581bc3414.png)

* **Step 1**  
i = 1일 때는 두 번째 원소인 '2'를 마지막 원소로 가지는 부분수열의 최대 길이를 구해야한다.  
단, 조건을 확인해 보면 '2'의 앞쪽에 위치한 원소는 '4'뿐이다. '4'는 '2'보다 더 크기 때문에 점화식에 따라 값이 갱신되지 않는다.  
 ![image](https://user-images.githubusercontent.com/78528903/182311490-80ee9701-7f1b-43c0-988b-9eb219873b1d.png)

* **Step 2**  
i = 2일 때는 세 번째 원소인 '5'를 마지막 원소로 가지는 부분수열의 최대 길이를 구해야한다.  
점화식에 따라 '5'의 앞쪽에 위치한 원소인 '4'와 '2'를 차례대로 비교해 봤을 때, 둘 다 '5'보다 작으므로 D[2]의 값을 차례대로 갱신한다.  
'4'보다 크므로 `D[2] = max(D[2], D[0] + 1) = 2`가 되고, 그 다음 원소인 '2'보다 역시 크므로 `D[2] = max(D[2], D[1] + 1)` 인데 이미 `D[2] = 2` 이므로 갱신은 되지 않는다.
  ![image](https://user-images.githubusercontent.com/78528903/182311570-9b4834bf-4eb4-42ce-ab7b-56c752ef50eb.png)  
.  
.  
.  
* **Step 6**  
위의 과정을 반복하면 최종적으로 DP 테이블에 담겨있는 값은 다음과 같다.  
![image](https://user-images.githubusercontent.com/78528903/182312629-b538675a-5767-47dc-84d6-922003d183f0.png)  
확인해보면 7번째 원소를 마지막 원소로 가지는 부분수열의 최대 길이는 5로 설정된 것을 확인할 수 있다.  
따라서 이와 같이 DP 테이블을 갱신한 뒤에 최종적으로 DP 테이블에 남아있는 값 중에서 가장 큰 값을 출력하도록 만들면, 증가하는 부분 수열 중에서 가장 긴 수열의 길이를 찾은 것이다.


## 답안 예시
```python
n = int(input())
array = list(map(int, input().split()))
# 순서를 뒤집어 '최장 증가 부분 수열' 문제로 변환
array.reverse()

# DP 테이블 초기화
dp = [1] * n

# 가장 긴 증가하는 부분 수열(LIS) 알고리즘 수행
for i in range(1, n):
    for j in range(0, i):
        if array[j] < array[i]:
            dp[i] = max(dp[i], dp[j] + 1)

print(n - max(dp))
```



