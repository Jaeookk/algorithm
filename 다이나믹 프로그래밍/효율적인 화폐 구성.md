## 문제 설명
* N가지 종류의 화폐가 있습니다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 합ㄴ디ㅏ. 이때 각 종류의 화폐는 몇 개라도 사용할 수 있습니다.
* 예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수입니다.
* M원을 만들기 위한 최소한의 화폐 개수를 출력하는 프로그램을 작성하세요.


## 문제 조건
* 입력 조건
  * 첫째 줄에 N, M이 주어진다. (1 <= N <= 100, 1 <= M <= 10,000)
  * 이후의 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐의 가치는 10,000보다 작거나 같은 자연수이다.
* 출력 조건
  * 첫째 줄에 경우의 수 X를 출력한다.
  * 불가능할 때는 -1을 출력한다.


## 문제 해결 아이디어
이 문제는 그리디에서 다루었던 거스름돈 문제와 거의 동일하다. 단지 화폐 단위에서 큰 단위가 작은 단위의 배수가 아니라는 점만 다르다.  
그렇기 때문에 그리디 알고리즘을 사용했던 예시처럼 매번 가장 큰 화폐 단위부터 처리하는 방법으로는 해결할 수 없고 다이나믹 프로그래밍을 이용해야 한다.  

이번 문제는 적은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 최소한의 화폐 개수를 찾으면 된다.
* $a_i$ = 금액 i를 만들 수 있는 최소한의 화폐 개수
* $k$ = 각 화폐의 단위
* **점화식** : 각 화폐 단위인 k를 **하나씩 확인하며**
  * $a_{i-k}$를 만드는 방법이 존재하는 경우, $a_i = min(a_i, a_{i-k}+1)$
  * $a_{i-k}$를 만드는 방법이 존재하지 않는 경우, $a_i = INF$

이 점화식을 모든 화폐 단위에 대하여 차례대로 적용하면 된다. 실제로 문제를 풀기 위해서는 가장 먼저 M의 크기만큼 리스트를 할당한다.  
이후에 각 인덱스를 '금액'으로 고려하여 메모이제이션을 진행한다.

예를 들어 N = 3, M = 7이고, 각 화폐의 단위가 2, 3, 5인 경우를 생각해보자.
* **Step 0 (초기화)**
  * 먼저 각 인덱스에 해당하는 값으로 INF의 값을 설정
  * INF은 특정 금액을 만들 수 있는 화폐 구성이 가능하지 않다는 의미를 가진다. 
  * 또한 0원의 경우, 화폐를 하나도 사용하지 않았을 때 만들 수 있으므로 값으로 0을 설정한다.  
![image](https://user-images.githubusercontent.com/78528903/182199312-b753b2e9-5918-4bb2-9eae-5fb82034f665.png)

* **Step 1**
  * 첫 번째 화폐 단위인 2를 확인
  * 점화식에 따라서 다음과 같이 리스트가 갱신된다.  
    * 예를 들어 인덱스 2의 경우 1이라는 값을 가지는데, 이는 2원짜리 화폐 하나를 이용하여 2원을 만들 수 있다는 의미이다. 다시 말해 $a_2 = a_0 + 1$ 이다.
![image](https://user-images.githubusercontent.com/78528903/182199476-2ee0e0ac-cf48-44a7-83a4-2425dcb08b60.png)

* **Step 2**
  * 두 번째 화폐 단위인 3을 확인
  * 점화식에 따라서 다음과 같이 리스트가 갱신된다.  
![image](https://user-images.githubusercontent.com/78528903/182199825-060868aa-c799-4cb3-b227-3d9c72055470.png)

* **Step 3**
  * 두 번째 화폐 단위인 5를 확인
  * 점화식에 따라서 다음과 같이 리스트가 갱신된다.  
![image](https://user-images.githubusercontent.com/78528903/182199871-ef825e66-2854-4975-a0f4-582512721f40.png)

## 답안 예시
```python
# 정수 N, M을 입력 받기
n, m = map(int, input().split())
# N개의 화폐 단위 정보를 입력받기
array = []
for i in range(n):
    array.append(int(input()))
    
# 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (m + 1)

# 다이나믹 프로그래밍 진행(보텀업)
d[0] = 0
for i in range(n):
    for j in range(array[i], m + 1):
        d[j] = min(d[j], d[j - array[i]] + 1)

if d[m] == 10001:
    print(-1)
else:
    print(d[m])
```

