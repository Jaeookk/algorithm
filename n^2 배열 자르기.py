# https://school.programmers.co.kr/learn/courses/30/lessons/87390

# [1,2,3,...,n], [2,2,3,4...,n], [3,3,3,4,5,...,n] , [...], [n-1,n-1,..., n-1], [n,n,n,...,n]를 1차원 배열로 하면 아래와 같다.
# 1,2,3,...,n, 2,2,3,4...,n, 3,3,3,4,5,...,n , ..., n-1,n-1,..., n-1, n,n,n,...,n
# 이때 left~right 사이의 값만 추출하는게 문제의 요구사항인데, 위의 2차원 배열 리스트를 구현하려면 시간초과가 난다.
# 즉, left ~ right 사이의 값만 추출해야 시간초과를 피할 수 있다.
# 한 배열은 처음 몇개의 원소만 제외하고 n까지 1씩 증가한다. 이는 left에서 시작한 인덱스를 n으로 나눈 나머지 + 1을 통해 구할 수 있다.
# 문제는 처음 몇개의 원소가 원래 2차원 배열의 행 인덱스값 만큼 중복되어 존재한다는 것인데(ex. 2번째 행은 2,2,3,4...)
# 이는 해당 인덱스를(1차원으로 변환했을때) n으로 나눈 몫 + 1과 같고, 그 개수도 n으로 나눈 몫 + 1개와 같다.


def solution(n, left, right):
    answer = [max(k % n, k // n) + 1 for k in range(left, right + 1)]
    return answer
